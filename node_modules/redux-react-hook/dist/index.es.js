import { createContext, useContext, useMemo, useState, useRef, useLayoutEffect, useEffect } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
// React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser.
var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;
var MissingProviderError = /** @class */ (function (_super) {
    __extends(MissingProviderError, _super);
    function MissingProviderError() {
        return _super.call(this, 'redux-react-hook requires your Redux store to be passed through ' +
            'context via the <StoreContext.Provider>') || this;
    }
    return MissingProviderError;
}(Error));
function memoizeSingleArg(fn) {
    var value;
    var prevArg;
    return function (arg) {
        if (prevArg !== arg) {
            value = fn(arg);
            prevArg = arg;
        }
        return value;
    };
}
function referenceEqual(a, b) {
    return a === b;
}
/**
 * To use redux-react-hook with stronger type safety, or to use with multiple
 * stores in the same app, create() your own instance and re-export the returned
 * functions.
 */
function create(_a) {
    var _b = (_a === void 0 ? {} : _a).defaultEqualityCheck, defaultEqualityCheck = _b === void 0 ? referenceEqual : _b;
    var StoreContext = createContext(null);
    /**
     * Your passed in mapState function should be memoized with useCallback to avoid
     * resubscribing every render. If you don't use other props in mapState, pass
     * an empty array [] as the dependency list so the callback isn't recreated
     * every render.
     *
     * const todo = useMappedState(useCallback(
     *   state => state.todos.get(id),
     *   [id],
     * ));
     */
    function useMappedState(mapState, equalityCheck) {
        if (equalityCheck === void 0) { equalityCheck = defaultEqualityCheck; }
        var store = useContext(StoreContext);
        if (!store) {
            throw new MissingProviderError();
        }
        // We don't keep the derived state but call mapState on every render with current state.
        // This approach guarantees that useMappedState returns up-to-date derived state.
        // Since mapState can be expensive and must be a pure function of state we memoize it.
        var memoizedMapState = useMemo(function () { return memoizeSingleArg(mapState); }, [
            mapState,
        ]);
        var state = store.getState();
        var derivedState = memoizedMapState(state);
        // Since we don't keep the derived state we still need to trigger
        // an update when derived state changes.
        var _a = useState(0), forceUpdate = _a[1];
        // Keep previously commited derived state in a ref. Compare it to the new
        // one when an action is dispatched and call forceUpdate if they are different.
        var lastStateRef = useRef(derivedState);
        var memoizedMapStateRef = useRef(memoizedMapState);
        // We use useLayoutEffect to render once if we have multiple useMappedState.
        // We need to update lastStateRef synchronously after rendering component,
        // With useEffect we would have:
        // 1) dispatch action
        // 2) call subscription cb in useMappedState1, call forceUpdate
        // 3) rerender component
        // 4) call useMappedState1 and useMappedState2 code
        // 5) calc new derivedState in useMappedState2, schedule updating lastStateRef, return new state, render component
        // 6) call subscription cb in useMappedState2, check if lastStateRef !== newDerivedState, call forceUpdate, rerender.
        // 7) update lastStateRef - it's too late, we already made one unnecessary render
        useIsomorphicLayoutEffect(function () {
            lastStateRef.current = derivedState;
            memoizedMapStateRef.current = memoizedMapState;
        });
        useIsomorphicLayoutEffect(function () {
            var didUnsubscribe = false;
            // Run the mapState callback and if the result has changed, make the
            // component re-render with the new state.
            var checkForUpdates = function () {
                if (didUnsubscribe) {
                    // Don't run stale listeners.
                    // Redux doesn't guarantee unsubscriptions happen until next dispatch.
                    return;
                }
                var newDerivedState = memoizedMapStateRef.current(store.getState());
                if (!equalityCheck(newDerivedState, lastStateRef.current)) {
                    forceUpdate(increment);
                }
            };
            // Pull data from the store after first render in case the store has
            // changed since we began.
            checkForUpdates();
            // Subscribe to the store to be notified of subsequent changes.
            var unsubscribe = store.subscribe(checkForUpdates);
            // The return value of useEffect will be called when unmounting, so
            // we use it to unsubscribe from the store.
            return function () {
                didUnsubscribe = true;
                unsubscribe();
            };
        }, [store]);
        return derivedState;
    }
    function useDispatch() {
        var store = useContext(StoreContext);
        if (!store) {
            throw new MissingProviderError();
        }
        return store.dispatch;
    }
    return {
        StoreContext: StoreContext,
        useDispatch: useDispatch,
        useMappedState: useMappedState,
    };
}
function increment(x) {
    return x + 1;
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
var _a;
var StoreContext = (_a = create(), _a.StoreContext), useDispatch = _a.useDispatch, useMappedState = _a.useMappedState;

export { StoreContext, create, useDispatch, useMappedState };
//# sourceMappingURL=index.es.js.map
